

{


  parserClass="com.vyperplugin.parser.VyperParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  implements="com.vyperplugin.psi.VyperElement"

  psiClassPrefix="Vyper"
  psiImplClassSuffix="Impl"
  psiPackage="com.vyperplugin.psi"
  psiImplPackage="com.vyperplugin.psi.impl"

  elementTypeHolderClass="com.vyperplugin.psi.VyperTypes"
  elementTypeClass="com.vyperplugin.psi.VyperElementType"
  tokenTypeClass="com.vyperplugin.psi.VyperTokenType"

  parserUtilClass = "com.vyperplugin.parser.ParserUtil"



tokens = [
   DECORATOR = '@'
   comment='regexp:(#.*)'
   SEMICOLON=';'
   COMMA=','
   DOT='.'
   COLON=':'
   LBRACKET='['
   RBRACKET=']'
   LBRACE='{'
   RBRACE='}'
   LPAREN='('
   RPAREN=')'
   IMPORT = 'import'
   FROM = 'from'

   PLUS='+'
   MINUS='-'
   MULT='*'
   DIV='/'
   EXPONENT='**'
   NOT='not'
   ASSIGN='='
   TO='=>'
   EQ='=='
   NEQ='!='
   PLUS_ASSIGN='+='
   MINUS_ASSIGN='-='
   MULT_ASSIGN='*='
   DIV_ASSIGN='/='
   PERCENT_ASSIGN='%='
   LESS='<'
   LESSEQ='<='
   MORE='>'
   MOREEQ='>='
   CARET='^'
   AND='and'
   OR='or'
   QUESTION='?'
   PERCENT='%'
   TILDE='~'
   LSHIFT='<<'
   RSHIFT='>>'

    hexLiteral='regexp:hex"([0-9a-fA-F]+)"'
    stringLiteralDouble='regexp:("([^"\r\n\\]|\\.)*")'
    stringLiteralDoubleB='regexp:(b"([^"\r\n\\]|\\.)*")'
    stringLiteralSingle="regexp:('([^'\r\n\\]|\\.)*')"
    stringLiteralSingleB="regexp:(b'([^'\r\n\\]|\\.)*')"
    MultiLineStringToken = 'regexp:("""([^"]|"[^"]|""[^"])*""")'

    decimalNumber='regexp:([0-9][_0-9]*)'
    fixedNumber='regexp:(([0-9][_0-9]*)+\.[_0-9]*|([0-9][_0-9]*)*\.([0-9][_0-9]*))'
    booleanLiteral='regexp:True|False'
    scientificNumber='regexp:((([0-9][_0-9]*)+|([0-9][_0-9]*)+\.[_0-9]*|([0-9][_0-9]*|[0-9])*\.[_0-9]+)[Ee][+-]?[_0-9]+)'
    hexNumber='regexp:(0[xX][_0-9a-fA-F]+)'

    public='public'
    private='private'
    nonreentrant='nonreentrant'
    payable='payable'
    nonpayable='nonpayable'
    external='external'
    view='view'
    pure='pure'
    event='event'
    range = 'range'

    newline = 'regexp:(\n|(\r\n))'
    WHITE_SPACE = 'regexp:\s+'

    Identifier='regexp:([A-Za-z_]\w*)'
    //add !@ etc.
//    BadStatementString = 'regexp:(\w+)'
    //ALL='regexp:[\^a-zA-Z_0-9.<>"]*' for preview
]

//to handle left recursion
extends(".*Expression") = Expression

}

VyperFile ::= ((!<<eof>> SourceUnit) (&INDEQ SourceUnit)*)?

external INDEQ ::= indEq
external INDEQNSP ::= indEqAndNoSpaces
external INDLT ::= indLt
external INDGT ::= indGt
external INDNONE ::= indNone
external OPTIND ::= indOpt

// : External interface and struct declarations must come before event declarations, global declarations,
// and function definitions
private SourceUnit ::= ( ImportDirective
                        | UserDefinedConstantsExpression
                        | ImplementsDirective
                        | StructDefinition
                        | UnitsDefinition
                        | ExternalInterfaces
                        | EventDeclaration
                        | FunctionDefinition
                        | StateVariableDeclaration
                        | BadStatement)
                        {recoverWhile=structRecover}


BadStatement ::= Identifier | StringLiteral |BAD_CHARACTER
private recoverINDLT ::= !(&INDLT)
/*
units: {
    cm: "centimeter",
    km: "kilometer"
}
*/
UnitsDefinition ::= UnitsDefinitionPrefix '}'

private UnitsDefinitionPrefix ::= units  (&INDNONE ':') (&INDNONE '{')
     ( (Identifier ':' StringLiteral) ( ',' Identifier ':' StringLiteral)* )?
  {
pin = 1
recoverWhile = unitsRecover
//programmatically check for trace newLine, probably to enable further parsing
}
//will consume all the file if '}' not found
private unitsRecover::=!('}')



UserDefinedConstantsExpression ::= Identifier &INDNONE ':' &INDNONE constant &INDNONE'(' TYPE ')' &INDNONE'=' &INDNONE Expression  {
 pin=5

 mixin = "com.vyperplugin.psi.VyperNamedElementImpl"
 implements = "com.vyperplugin.psi.VyperNamedElement"
}

private ImportDirective ::= ( import &INDNONE IMPORT_PATH &INDNONE as &INDNONE Identifier )
                   |( from  &INDNONE IMPORT_PATH &INDNONE import &INDNONE Identifier  )  {
pin(".*")=1
}

IMPORT_PATH ::= Identifier  (&INDNONE '.' &INDNONE Identifier)*

// implements statements
ImplementsDirective ::=  implements &INDNONE ':' &INDNONE Identifier (&INDNONE ',' &INDNONE Identifier )* {
pin=1
}

// external interfaces ok
ExternalInterfaces ::= interface &INDNONE Identifier &INDNONE ':'
                        <<indented (ExternalInterfaceBody+) >>
                {pin=1}

private ExternalInterfaceBody ::= ( def &INDNONE Identifier &INDNONE '('
( FunctionArgs)? ')' (&INDNONE '->' &INDNONE TYPE)? &INDNONE ':' &INDNONE ExternalFunStatus )
{pin = 1}
private ExternalFunStatus ::= pure | view | nonpayable | payable

FunctionArgs ::= ParamDef  (',' ParamDef )*

ParamDef ::= Identifier ':' TYPE ('=' Expression)? {
            mixin = "com.vyperplugin.psi.VyperNamedElementImpl"
            implements = "com.vyperplugin.psi.VyperNamedElement"
}
// could be default assignment
StructDefinition ::= struct &INDNONE Identifier &INDNONE COLON  StructBody {
pin = 1
}

private StructBody ::= StructSingleDef | <<indented (StructMultipleDef) >>
private StructSingleDef ::= (&INDNONE StructLocalVariableDefinition)

private StructMultipleDef ::= StructLocalVariableDefinition (&INDEQ StructLocalVariableDefinition )*
//{recoverWhile=recoverStruct}
private StructLocalVariableDefinition ::= LocalVariableDefinition | BadStatement
{recoverWhile=structRecover}

//private recoverINDEQ ::=!(&INDEQ)
private structRecover ::= !(&INDEQ | &INDLT |<<eof>>)
private recoverStruct ::= !(&INDLT | &INDEQ)

//ok
//Events must all come before global declarations and function definitions
EventDeclaration ::= event &INDNONE Identifier &INDNONE ':' ((&INDGT EventProperty?) | (&INDNONE pass))  {
pin=5
}

EventProperty ::= Identifier ':'    (IndexedData | TYPE)
                (Identifier ':' (IndexedData |TYPE))*

IndexedData ::= IndexedType '(' TYPE ')'

private IndexedType ::= 'indexed'

// VARIABLES

// state variables  May not assign value whilst defining type
StateVariableDeclaration ::= Identifier &INDNONE ':' (  (&INDNONE StateVariableModifier &INDNONE '(' &INDNONE TYPE &INDNONE ')')
| (&INDNONE TYPE ))
{
mixin = "com.vyperplugin.psi.VyperNamedElementImpl"
implements = "com.vyperplugin.psi.VyperNamedElement"
}
// StateVariableModifier if omitted then it's private. () to not shadow private
StateVariableModifier ::= public | (private)


// semantic : map could not be inside functions
LocalVariableDefinition ::=  ( LocalVariableDeclaration (&INDNONE '=') (&INDNONE Expression) ) |
                           LocalVariableDeclaration

LocalVariableDeclaration ::= Identifier &INDNONE ':' &INDNONE TYPE {

mixin = "com.vyperplugin.psi.VyperNamedElementImpl"
implements = "com.vyperplugin.psi.VyperNamedElement"

}

//Colon ::= (&INDNONE ':')
//Type ::=  (&INDNONE TYPE)

MultiLineString ::=  MultiLineStringToken

// FUNCTIONS

private FunDef ::= def (&INDNONE Identifier) (&INDNONE '(') FunctionArgs?  ')' (&INDNONE '->' &INDNONE TYPE)? (&INDNONE ':')
                   {pin = 1}
private FunBody ::= (&INDNONE Statement)
                    | <<indented ((MultiLineString)? &INDEQ Statement (&INDEQ Statement)*) >>
FunctionDefinition ::=
    FunctionModifier (&INDEQ FunctionModifier)*
//    def &INDNONE Identifier &INDNONE '(' FunctionArgs?  ')' (&INDNONE '->' &INDNONE TYPE)? (&INDNONE ':')
//    FunBody
    FunDef
    FunBody
   {pin=1
   implements = "com.vyperplugin.psi.VyperFunctionDefElement"
   mixin = "com.vyperplugin.psi.VyperFunctionDefMixin"}


//FunctionModifier ::= (&INDEQ FunctionModifierOptional)* (&INDEQ FunctionModifierMandatory) (&INDEQ FunctionModifierOptional)*
//private FunctionModifierMandatory ::= DECORATOR ((&INDNONE public) | (&INDNONE private)) {pin = 1}
FunctionModifier ::=  (DECORATOR (&INDNONE (public | internal | view | pure | external | private | nonpayable | payable | (nonreentrant (&INDNONE '(') UNIQUE_KEY ')'))))
                      {pin = 1}

UNIQUE_KEY ::=  stringLiteralSingle | stringLiteralDouble

// statements
Statement ::= PassStatement
              | IfStatement
              | ForStatement
              | Continue
              | Break
              | Return
              | Raise
              | EmitStatement
              | SimpleStatement
              | BadStatement
              {recoverWhile = recoverStatement}

private recoverStatement ::= !(&INDEQ|&INDLT)


private CondStmt ::= Expression &INDNONE ':' ((&INDNONE Statement)
                                     | <<indented (Statement (&INDEQ Statement)*)>>)

private ElifStmt ::= elif &INDNONE CondStmt
                     {pin = 1}

private ElseStmt ::= else &INDNONE ':' ((&INDNONE Statement)
                                       | <<indented (Statement (&INDEQ Statement)*)>>)
                     {pin = 1}

IfStatement ::= if &INDNONE CondStmt
                (&INDEQ ElifStmt)*
                (&INDEQ ElseStmt)?
                {pin=1}


private SimpleStatement ::= LocalVariableDefinition | ExpressionStatement
private ExpressionStatement ::= Expression

ForStatement ::= for &INDNONE Identifier &INDNONE in &INDNONE Expression &INDNONE ':'
                    (&INDNONE Statement
                    | <<indented (Statement (&INDEQ Statement)*)>>){
pin=1
}


private Continue ::= continue

private Break ::= break

private Return ::= return (&INDNONE Expression)? {
pin=1
}
private Raise ::= raise

EmitStatement ::= 'log.' &INDNONE FunctionCallExpression {
pin=1
}

private PassStatement ::= pass

Expression ::=
  AssignmentExpression
  | RangeExpression
//  | FunctionCallExpression
  | ParenthesiziedExpression
  | CallExpression
  | NewExpression
  | AssertExpression
  | EqExpression
  | OrExpression
  | AndExpression
  | CompExpression
  | PlusMinExpression
  | MultDivExpression
  | ExponentExpression
  | UnaryExpression
  | ClearExpression
  | IndexAccessExpression
//  | SelfAccessExpression
//  | SelfFunctionCall
  | MemberAccessExpression
  | MemberIndexAccess
  | InlineArrayExpression
  | PrimaryExpression
  | EventLogExpression

EventLogExpression ::= log &INDNONE Identifier '(' Expression (',' Expression)* ')'


//self function call?

private RangeInterval ::= PrimaryExpression ',' PrimaryExpression ',' PrimaryExpression
                         | PrimaryExpression ',' PrimaryExpression
                         | PrimaryExpression


RangeExpression ::= range &INDNONE '(' (Expression | RangeInterval ) ')'


//SelfAccessExpression ::= self (&INDNONE '.') (&INDNONE Expression)


//SelfFunctionCall ::= self &INDNONE '.' Identifier &INDNONE '(' (FunctionArgs)? ')'

NewExpression ::= Identifier (&INDNONE'(') '{' (  ((Identifier &INDNONE ':' &INDNONE Expression) | NewExpression)
                             (',' ((Identifier &INDNONE ':' &INDNONE Expression) | NewExpression))*)? '}' ')'

AssignmentExpression ::=
    Expression (&INDNONE ('=' | '+=' | '-=' | '*=' | '/=' | '%='))
    Expression { rightAssociative=true  }
//??
CallExpression ::= Expression
//&INDNONE '.' Identifier ) |
                 (   &INDNONE '[' Expression ']'  )*
                  &INDNONE '(' FunctionCallArguments? ')' (&INDNONE '(' FunctionCallArguments? ')')*
                  {
                  implements = "com.vyperplugin.psi.VyperReferenceElement"
                  mixin = "com.vyperplugin.psi.VyperCallElement"

                  }

//??
FunctionCallExpression ::= (Identifier &INDNONE '(' FunctionCallArguments? ')') |
                           ( ( PrimaryExpression | NewExpression | TypeName  )
                           ( ( &INDNONE '.' Identifier ) | ( &INDNONE '[' Expression? ']' ) )*
                                     &INDNONE '(' FunctionCallArguments? ')' )  {
   //implements and mixin
}


//left recursion?
MemberAccessExpression ::= Expression &INDNONE '.' (&INDNONE VarLiteral) {
    name = "member access"
}
MemberIndexAccess ::=  Expression &INDNONE '.' Expression &INDNONE '[' Expression']' {extends=Expression}
//recover?
IndexAccessExpression ::= Expression &INDNONE '[' Expression']'
//recover?
ParenthesiziedExpression ::= '(' Expression ')' {pin = 1}

ClearExpression ::= clear &INDNONE '(' Expression ')' {pin=1}


UnaryExpression ::=  (NOT | '~'  |  '+' | '-') &INDNONE Expression
InlineArrayExpression ::= '[' Expression (',' Expression)*  ']' {pin = 1}
AndExpression ::=  Expression AND Expression
OrExpression ::= Expression OR Expression
EqExpression ::= Expression ('==' | '!=') Expression
CompExpression ::= Expression ('<' | '>' | '<=' | '>=') Expression

PlusMinExpression ::= Expression ('+' | '-') Expression
MultDivExpression ::= Expression ('*' | '/' | '%') Expression
ExponentExpression ::= Expression '**' Expression

//multistring??
AssertExpression ::= assert &INDNONE Expression (&INDNONE AssertMessage)? {
    pin = 1
    name = "assert expression"
}
private AssertMessage ::= ',' (stringLiteralDouble| stringLiteralSingle | MultiLineString)

FunctionCallArguments ::= Expression? ( &INDNONE ',' Expression )*




PrimaryExpression ::=
                  | VarLiteral
                  | BooleanLiteral
                  | NumberLiteral
                  | HexLiteral
                  | StringLiteral
                  //type??
                  | TYPE

VarLiteral ::= Identifier {implements = "com.vyperplugin.psi.VyperReferenceElement"
                           mixin = "com.vyperplugin.psi.VyperVarLiteralMixin"
                           name = "variable"
                           }

//BuiltIn ::= 'bitwise_and' | 'bitwise_not' | 'bitwise_or' | 'bitwise_xor' | 'shift' | 'create_minimal_proxy_to' | 'create_copy_of' | 'create_from_blueprint' | 'raw_call' | 'raw_log' | 'raw_revert' | 'selfdestruct' | 'send' | 'ecadd' | 'ecmul' | 'ecrecover' | 'keccak256' | 'sha256' | 'concat' | 'convert' | 'uint2str' | 'extract32' | 'slice' | 'abs' | 'ceil' | 'epsilon' | 'floor' | 'max' | 'max_value' | 'min' | 'min_value' | 'pow_mod256' | 'sqrt' | 'isqrt' | 'uint256_addmod' | 'uint256_mulmod' | 'unsafe_add' | 'unsafe_sub' | 'unsafe_mul' | 'unsafe_div' | 'as_wei_value' | 'blockhash' | 'empty' | 'len' | 'method_id' | '_abi_encode' | '_abi_decode' | 'print'


// TYPES seems okay
TYPE ::=  ReferenceType | ValueType | StructType

ValueType ::= int128 | uint256| bytes32 | address
             | (bytes32 | bytes) &INDNONE '[' (DecimalNumber | Identifier) ']' | fixed | bool |
                string   &INDNONE '[' (DecimalNumber | Identifier) ']'

private ReferenceType ::= ListType  | MapType

ListType ::= ( ValueType | StructType ) &INDNONE '[' (DecimalNumber | Identifier) ']'
                    (&INDNONE '[' (DecimalNumber | Identifier) ']')*
StructType ::= Identifier {implements = "com.vyperplugin.psi.VyperReferenceElement"
                                                     mixin = "com.vyperplugin.psi.VyperStructTypeMixin"}

MapType ::= ( map  &INDNONE '(' ValueType  ',' ( ReferenceType |  ValueType | StructType  ) ')' ) |
 ( HashMap &INDNONE '[' ValueType ',' ( ReferenceType |  ValueType | StructType  ) ']' )
 {
pin=1
}

private BooleanLiteral ::= booleanLiteral
private NumberLiteral ::= HexNumber | DecimalNumber |FixedNumber
private StringLiteral ::= stringLiteralDouble | stringLiteralDoubleB | stringLiteralSingle | stringLiteralSingleB|MultiLineString
private DecimalNumber ::= decimalNumber
private HexNumber ::= hexNumber
private HexLiteral ::= hexLiteral
private  FixedNumber ::=fixedNumber
